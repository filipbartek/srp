\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}

\usepackage{amsfonts} % mathbb
\newcommand{\nn}{\mathbb{N}_n}

\newcommand{\file}[1]{\texttt{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\clpfd}{\acrshort{clpfd}}
\newcommand{\prolog}{Prolog}
\newcommand{\sicstusprolog}{SICStus \prolog{}}
\newcommand{\srp}{\acrshort{srp}}

% Required by glossaries
% http://tex.stackexchange.com/a/93770
\usepackage{datatool}

% http://en.wikibooks.org/wiki/LaTeX/Importing_Graphics
\usepackage{graphicx}
\graphicspath{ {./graphics/} }

\usepackage{hyperref}

\usepackage{glossaries}
\newacronym{srp}{SRP}{stable roommates problem}
\newacronym{clpfd}{\code{clpfd}}{Constraint Logic Programming over Finite Domains}
\newacronym{ff}{\code{ff}}{first-fail}
\makeglossaries

\begin{document}
\title{\Acrlong{srp} solver}
\author{Filip BÃ¡rtek}
\maketitle

\section{Problem definition}

Let's have $n$ participants.
Each participant knows some of the participants,
let's call these her potential partners.
Each participant has a linear ordering of her potential partners according
to preference.

Note that a participant may or may not consider herself a potential partner,
i.e. the relation of potential partnership needn't be irreflexive.

A matching is an equivalence relation on participants that has classes of size
at most 2,
i.e. assigns each participant one or none partner.
Matching must assign a potential partner to each of the participants.

An instability in a matching is a pair of participants each of whom prefers (according to their personal preference relations) the other to their current partner.

A stable matching is a matching that doesn't admit an instability.

In \acrfull{srp}, given preferences of each participant,
the task is to find a stable matching.

\subsection{Perfect matching}
A perfect matching is a matching in which every participant is assigned somebody else.

Once we can solve general \srp{},
we can force a perfect matching by making sure that no participant considers herself
a potential partner.

\section{Constraint model}
In this section we'll describe a model for \srp{} instance on $n$ participants.

We'll use the symbol $\nn$ to denote the set $\{1, \ldots, n\}$.
Each participant is uniquely identified by a number from $\nn$.

Note that the choice of variables and constraints corresponds to the capabilities
of \clpfd{}, a library that is used prominently in the implementation
of the solver.

\subsection{Variables}
\paragraph{Problem instance}
We'll represent an instance of \srp{} with $n$ participants as
a collection of preference lists $P = (P_1, \ldots, P_n)$.
$P_i$ is a preference list expressing preferences of participant $i$.
It's a $k_i$-tuple of participant identifiers (i.e. numbers from $\nn$).
All potential partners of participant $i$ are listed in $P_i$ in order of decreasing
desirability without duplicities.

\paragraph{Problem solution}
$m: \nn \rightarrow \nn$ assigns each participant her partner.

\paragraph{Auxiliary variables}
Let $s: \nn \times \nn \rightarrow \nn$ be a score function.
$s(i,j)$ represents how desirable participant $j$ is according to participant $i$.
The lower the score, the more desirable participant $j$ is.

$s$ is defined uniquely for a given instance $P$.
For every participant $i$:

\begin{itemize}
\item $j$-th potential partner is assigned score $j$
\item every participant which is not a potential partner is assigned a score $n$
\end{itemize}

As a convenience, let $\bar{s}(i)$ denote the score that participant $i$ assigns to her partner.

\subsection{Constraints}
Since the score function $s$ depends uniquely and trivially
to the problem instance $P$,
construction of $s$ from $P$ is realized
using standard \prolog{} code (without the use of \clpfd{}) and as such,
I'll leave out formal definition of the corresponding constraint.

Similarly, the properties of $P$ are not enforced formally so I'll leave out their
formal definitions.
Informal description of these properties are available in the previous section.

The following constraints constrain the solution $m$ based on $P$ and $s$:

\begin{tabular}{l | l}
Constraint & Explanation \\
\hline
$\forall i. m(i) \in P_i$ & Matching satisfies potential partners \\
$\forall i,j. m(i) = j \Leftrightarrow m(j) = i$ & Matching is symmetric \\
$\forall i. \bar{s}(i) = s(i, m(i))$ & $\bar{s}$ corresponds to $s$ and $m$ \\
$\forall i,j. \bar{s}(i) \leq s(i,j) \vee \bar{s}(j) \leq s(j,i)$ & All pairs are stable
\end{tabular}

Note especially the last of these constraints
as it captures the essence of the problem, that is the requirement of stability.
An instability occurs when a pair of participants prefer each other to their partners.
The constraint ensures that in each pair of participants,
at least one of them prefers her partner (i.e.~assigns her a lower score)
to the other participant.

\section{Implementation}
I've implemented the constraint model introduced in the previous section
using \sicstusprolog{} and its \clpfd{} library.
The implementation is available in the attached file \file{srp.pl}.

\subsection{Usage}
The main entry point is the predicate \code{srp/2}.
Its typical usage is \code{srp(Preferences, Matching)},
where \code{Preferences} is a fully instantiated list of ordered lists
of potential partners
and \code{Matching} is unbound.
If a solution of \srp{} instance described by \code{Preferences} exists,
it is unified with \code{Matching}.
Otherwise \code{srp} fails.

Internally, \code{srp} uses \clpfd{} library to search for the solution.
The searching procedure executed by \code{clpfd:labeling/2}
can optionally be customized by passing a list of options in the first argument
of \code{labeling}.
This argument of \code{labeling} is exposed
in the third argument of the extended \code{srp/3}.
For example, one may execute \code{srp(Preferences, Matching, [ffc, assumptions(K)])}.

\subsection{Example instances}
Examples of problem instances for the solver are included in file \file{srp.pl}
in unit tests for \code{srp/2}
(in a block starting with statement \code{:- begin\_tests(srp\_2).}).

\subsection{Correctness}
Correctness of the implementation was assessed using a set of tests on small
manually constructed and solved \srp{} instances (up to size 8).

The tests are bundled in the source file \file{srp.pl}
and can be accessed using \code{plunit} library interface
(typically by executing \code{plunit:run\_tests.}).

\subsection{Performance}
I've examined the performance of the solver using various problem instances
(esp.~of various sizes) and search strategies.

\subsubsection{System configuration}
The performance measurements were performed on a computer
with the following configuration:

\begin{tabular}{| l | l |}
\hline
Model & HP Compaq 6510b \\
\hline
CPU & Intel Core2 Duo T8100 2.10 GHz \\
\hline
RAM & 2.50 GB \\
\hline
Operating system & Windows Vista Business 32-bit \\
\hline
\sicstusprolog{} & 4.2.3 \\
\hline
\end{tabular}

\subsubsection{Instance generation}
For the purposes of measuring performance of the solver,
instances of \acrshort{srp} were generated randomly in the following manner:
for a given $n$, each of the $n$ participants' preference lists
is a random permutation of $\nn$
such that every possible permutation occurs with equal probability.

\subsubsection{Measurement procedure}
The following instance sizes (values of $n$) were examined:
0, 1, 2, 4, 8, 16, 24, 32, 40, 48, 64, 72, 80 and 88.
I didn't proceed past the size 88
because at $n = 96$ the solver failed because of insufficient memory.

For every examined value of $n$, 10 random instances were generated.

For sizes up to 64,
each of these 10 instances was solved using each of the three relevant basic
search strategies offered by \code{clpfd:labeling/2}:

\begin{itemize}
\item \code{leftmost},
\item \acrshort{ff} (\acrlong{ff}) and
\item \code{ffc} (most constrained).
\end{itemize}

Since \code{leftmost} performed time-wise significantly worse
than \acrshort{ff} and \code{ffc} (see figure \ref{fig:time}),
I left it out of measurements on sizes larger than 64.

Two values were measured: \emph{time to find a solution}
and \emph{number of assumptions taken in finding the first solution}.

Time was measured using \sicstusprolog{} built-in predicate \code{statistics/2}
with keyword \code{runtime}.
The solving procedure was repeated
100 times on instances of size at most 32,
10 times on instances of size between 40 and 56
and 1 time on instances of size above 56.
(see figure \ref{fig:executions}).
The running times discussed further on are averages across these executions.

\begin{figure}
\centering
\includegraphics[width=\linewidth]{executions}
\caption{Number of executions of solver for time measurement}
\label{fig:executions}
\end{figure}

Assumptions are the choices made by \code{clpfd:labeling/2}
during the search for a solution.
Their number is extracted from the search procedure using the option
\code{assumptions(K)}.

In all cases, the solver was only run until it found any solution
or concluded that no solution exists for the given instance.
Rationale: since there is no defined distinction between the valid solutions,
I assume that the user of the solver will typically be satisfied
with any valid solution, or knowledge of its absence.

The numbers of assumptions were only measured on soluble instances.
For all instance sizes, at least 5 of the 10 generated instances had a solution
(see figure \ref{fig:soluble}).

\begin{figure}
\centering
\includegraphics[width=\linewidth]{soluble}
\caption{Number of soluble instances}
\label{fig:soluble}
\end{figure}

\subsubsection{Results}
The raw measured data can be examined in the attached file \file{data.csv}.

\paragraph{Assumptions}
The average numbers of assumptions made in the search for the first solution
are shown in figure \ref{fig:assumptions}.
The averages run across the soluble instances of a given size
(at least 5 and up to 10, as indicated in \ref{fig:soluble}).

Note that the numbers of assumptions happen to match
for strategies \acrshort{ff} and \code{ffc}
(on an instance-to-instance basis, not only the averages).
Since \code{ffc} chooses the most constrained variable
where \acrshort{ff} simply chooses the first declared variable,
I suppose that the implementation simply happens to declare the variables
in descending order of number of suspended constraints.
%TODO: Verify.

In the chart you can see that the number of assumptions rises with instance size
and rises more quickly for the strategy \code{leftmost}.
This is to be expected since \acrshort{ff} and \code{ffc} use more elaborate heuristics
for lowering the expected number of assumptions.

\begin{figure}
\centering
\includegraphics[width=\linewidth]{assumptions}
\caption{Average number of assumptions}
\label{fig:assumptions}
\end{figure}

You can see the dispersion of number of assumptions among instances of a given size
for search strategy \acrshort{ff} in figure \ref{fig:ff-assumptions}.

\begin{figure}
\centering
\includegraphics[width=\linewidth]{ff_assumptions}
\caption{Dispersion of number of assumptions with search strategy \acrshort{ff}}
\label{fig:ff-assumptions}
\end{figure}

\paragraph{Running times}
Average running times for various instance sizes and search strategies are shown
in figure \ref{fig:time}.
The averages run across 10 instances of a given size.

\begin{figure}
\centering
\includegraphics[width=\linewidth]{time}
\caption{Average solving time}
\label{fig:time}
\end{figure}

As expected from the numbers of assumptions,
the strategies \acrshort{ff} and \code{ffc} perform similarly well.
Their running times are hardly distinguishable in the chart.
This suggests namely that the overhead of using
the more complex heuristics of \code{ffc} over \acrshort{ff} is negligible.

You can also observe a steep jump in running time
of the strategy \code{leftmost} at instance size 64.
Since \acrshort{ff} and \code{ffc} adapt to larger instance sizes more smoothly
and perform well even on smaller instances,
they appear to be better choices in general for this solver.

The running times differ a lot among instances of a given size.
As an example a box plot of running times with strategy \acrshort{ff} is shown
in figure \ref{fig:ff-time}.

\begin{figure}
\centering
\includegraphics[width=\linewidth]{ff_time}
\caption{Dispersion of running time with search strategy \acrshort{ff}}
\label{fig:ff-time}
\end{figure}

Note that \srp{} was shown to be soluble
in quadratic time.\footnote{Source: Wikipedia - Stable roommates problem}

\section{Conclusions}
It appears that the delivered implementation of \srp{} solver can be used
for fast solving of problem instances of sizes up to approximately 88.
The measured average time for solving an instance of size 88
with search strategy \acrshort{ff} is approximately 2 seconds.

The search strategies \acrshort{ff} and \code{ffc}
perform significantly better than the strategy \code{leftmost}
on instances of size at least 48.

\printglossaries{}

\end{document}
